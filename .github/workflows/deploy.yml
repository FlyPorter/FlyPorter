name: Build and Deploy to Digital Ocean Kubernetes

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'k8s/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:  # Allow manual trigger

env:
  REGISTRY: registry.digitalocean.com
  IMAGE_NAME: flyporter-backend
  REGISTRY_NAME: flyporter

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    # Step 1: Checkout code
    - name: Checkout code
      uses: actions/checkout@v3

    # Step 2: Install doctl (Digital Ocean CLI)
    - name: Install doctl
      uses: digitalocean/action-doctl@v2
      with:
        token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

    # Step 3: Login to DO Container Registry
    - name: Login to Digital Ocean Container Registry
      run: doctl registry login --expiry-seconds 1200

    # Step 4: Build Docker image
    - name: Build Docker image
      run: |
        docker build \
          --platform linux/amd64 \
          -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:latest \
          -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          ./backend

    # Step 5: Push Docker image
    - name: Push Docker image to DO Registry
      run: |
        docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:latest
        docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

    # Step 6: Set up kubectl
    - name: Setup kubectl
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    # Step 7: Verify cluster connection
    - name: Verify cluster connection
      run: |
        kubectl cluster-info
        kubectl get nodes

    # Step 8: Apply Kubernetes configurations (ConfigMap, Deployment, etc.)
    - name: Apply Kubernetes configurations
      run: |
        # Apply namespace first (idempotent)
        kubectl apply -f k8s/namespace.yaml || true
        
        # Apply cert-issuer for HTTPS (idempotent)
        kubectl apply -f k8s/cert-issuer.yaml || true
        
        # Apply ConfigMap
        kubectl apply -f k8s/configmap.yaml
        
        # Apply Service (needed for Ingress)
        kubectl apply -f k8s/service.yaml
        
        # Apply Ingress (needed for HTTPS)
        kubectl apply -f k8s/ingress.yaml
        
        # Apply Deployment
        kubectl apply -f k8s/deployment.yaml

    # Step 9: Update Kubernetes deployment image
    - name: Deploy to Kubernetes
      run: |
        kubectl set image deployment/flyporter-backend \
          backend=${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          -n flyporter
        
        # Wait for rollout to complete
        kubectl rollout status deployment/flyporter-backend -n flyporter --timeout=5m

    # Step 10: Verify deployment
    - name: Verify deployment
      run: |
        echo "Checking pod status..."
        kubectl get pods -n flyporter
        
        echo "Checking service..."
        kubectl get svc flyporter-backend -n flyporter

    # Step 11: Run health check
    - name: Health check
      run: |
        # Wait for deployment rollout to complete
        echo "Waiting for deployment rollout..."
        kubectl rollout status deployment/flyporter-backend -n flyporter --timeout=5m
        
        # Wait for pods to be ready
        echo "Waiting for pods to be ready..."
        sleep 10
        
        # Test health endpoint via HTTPS domain
        echo "Testing health endpoint via HTTPS domain..."
        if curl -f https://api.flyporter.website/api/health; then
          echo "HTTPS health check passed!"
          echo "Deployment successful! Backend is live at https://api.flyporter.website"
        else
          echo "HTTPS health check failed, falling back to direct service IP..."
          EXTERNAL_IP=$(kubectl get svc flyporter-backend -n flyporter -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -n "$EXTERNAL_IP" ]; then
            echo "Testing via service IP: http://$EXTERNAL_IP"
            curl -f http://$EXTERNAL_IP:3000/api/health || exit 1
            echo "Health check passed via service IP"
          else
            echo "Error: Could not determine service IP"
            exit 1
          fi
        fi

